package com.guyghost.wakeve.ui.meal

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.outlined.Comment
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.guyghost.wakeve.meal.MealPlanner
import com.guyghost.wakeve.meal.MealRepository
import com.guyghost.wakeve.models.*
import com.guyghost.wakeve.comment.CommentRepository
import com.guyghost.wakeve.models.CommentSection
import java.time.LocalDate
import java.time.format.DateTimeFormatter

/**
 * Meal Planning Screen
 * 
 * Features:
 * - List meals grouped by date (Daily Schedule)
 * - Filter by type and status
 * - Add/Edit/Delete meals
 * - Auto-generate meal plan
 * - Manage dietary restrictions
 * - Assign responsibilities
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MealPlanningScreen(
    eventId: String,
    mealRepository: MealRepository,
    commentRepository: CommentRepository,
    onNavigateBack: () -> Unit,
    onNavigateToComments: (eventId: String, section: CommentSection, sectionItemId: String?) -> Unit
) {
    var dailySchedules by remember { mutableStateOf<List<DailyMealSchedule>>(emptyList()) }
    var dietaryRestrictions by remember { mutableStateOf<List<ParticipantDietaryRestriction>>(emptyList()) }
    var selectedType by remember { mutableStateOf<MealType?>(null) }
    var selectedStatus by remember { mutableStateOf<MealStatus?>(null) }
    var showAddMealDialog by remember { mutableStateOf(false) }
    var showAutoGenerateDialog by remember { mutableStateOf(false) }
    var mealToEdit by remember { mutableStateOf<Meal?>(null) }
    var mealToDelete by remember { mutableStateOf<Meal?>(null) }
    var showDietaryRestrictionsDialog by remember { mutableStateOf(false) }
    var commentCount by remember { mutableIntStateOf(0) }
    
    // Load data
    fun loadData() {
        dailySchedules = mealRepository.getDailyMealSchedule(eventId)
        dietaryRestrictions = mealRepository.getDietaryRestrictionsByEventId(eventId)
        commentCount = commentRepository.countCommentsBySection(eventId, CommentSection.MEAL).toInt()
    }
    
    LaunchedEffect(eventId) {
        loadData()
    }
    
    // Flatten and filter meals
    val allMeals = dailySchedules.flatMap { it.meals }
    val filteredMeals = allMeals.filter { meal ->
        val typeMatch = selectedType == null || meal.type == selectedType
        val statusMatch = selectedStatus == null || meal.status == selectedStatus
        typeMatch && statusMatch
    }
    
    // Regroup filtered meals by date
    val filteredSchedules = MealPlanner.groupMealsByDate(filteredMeals)
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Planification des repas") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.Default.ArrowBack, "Retour")
                    }
                },
                actions = {
                    // Dietary restrictions button
                    IconButton(onClick = { showDietaryRestrictionsDialog = true }) {
                        Badge(
                            containerColor = if (dietaryRestrictions.isNotEmpty()) 
                                MaterialTheme.colorScheme.error 
                            else 
                                MaterialTheme.colorScheme.surfaceVariant
                        ) {
                            Text(dietaryRestrictions.size.toString())
                        }
                    }
                    
                    // Auto-generate button
                    IconButton(onClick = { showAutoGenerateDialog = true }) {
                        Icon(Icons.Default.AutoAwesome, "Générer automatiquement")
                    }

                    // Comments icon with badge
                    IconButton(onClick = {
                        onNavigateToComments(eventId, CommentSection.MEAL, null)
                    }) {
                        Box {
                            Icon(
                                Icons.Outlined.Comment,
                                contentDescription = if (commentCount == 0) "Aucun commentaire" else "$commentCount commentaires"
                            )
                            if (commentCount > 0) {
                                Box(
                                    modifier = Modifier
                                        .size(16.dp)
                                        .background(
                                            color = MaterialTheme.colorScheme.error,
                                            shape = CircleShape
                                        )
                                        .align(Alignment.TopEnd),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Text(
                                        text = commentCount.toString(),
                                        style = MaterialTheme.typography.labelSmall,
                                        color = MaterialTheme.colorScheme.onError,
                                        fontWeight = FontWeight.Bold
                                    )
                                }
                            }
                        }
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = { showAddMealDialog = true }
            ) {
                Icon(Icons.Default.Add, "Ajouter un repas")
            }
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        ) {
            // Summary card
            if (allMeals.isNotEmpty()) {
                MealSummaryCard(
                    meals = allMeals,
                    dietaryRestrictions = dietaryRestrictions
                )
            }
            
            // Filter chips
            MealFiltersRow(
                selectedType = selectedType,
                selectedStatus = selectedStatus,
                onTypeSelected = { selectedType = if (it == selectedType) null else it },
                onStatusSelected = { selectedStatus = if (it == selectedStatus) null else it }
            )
            
            // Meal list grouped by date
            if (filteredSchedules.isEmpty()) {
                // Empty state
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        Icon(
                            Icons.Default.Restaurant,
                            contentDescription = null,
                            modifier = Modifier.size(64.dp),
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Text(
                            "Aucun repas planifié",
                            style = MaterialTheme.typography.titleLarge
                        )
                        Text(
                            "Ajoutez votre premier repas ou générez un plan automatiquement",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Button(onClick = { showAutoGenerateDialog = true }) {
                                Icon(Icons.Default.AutoAwesome, contentDescription = null)
                                Spacer(Modifier.width(8.dp))
                                Text("Générer")
                            }
                            OutlinedButton(onClick = { showAddMealDialog = true }) {
                                Icon(Icons.Default.Add, contentDescription = null)
                                Spacer(Modifier.width(8.dp))
                                Text("Ajouter")
                            }
                        }
                    }
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize(),
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    filteredSchedules.forEach { schedule ->
                        item {
                            DailyScheduleSection(
                                schedule = schedule,
                                onMealClick = { mealToEdit = it },
                                onDeleteClick = { mealToDelete = it }
                            )
                        }
                    }
                }
            }
        }
    }
    
    // Dialogs
    if (showAddMealDialog) {
        AddEditMealDialog(
            meal = null,
            eventId = eventId,
            onDismiss = { showAddMealDialog = false },
            onSave = { request ->
                mealRepository.createMeal(request)
                loadData()
                showAddMealDialog = false
            }
        )
    }
    
    mealToEdit?.let { meal ->
        AddEditMealDialog(
            meal = meal,
            eventId = eventId,
            onDismiss = { mealToEdit = null },
            onSave = { request ->
                val updated = meal.copy(
                    type = request.type,
                    name = request.name,
                    date = request.date,
                    time = request.time,
                    location = request.location,
                    responsibleParticipantIds = request.responsibleParticipantIds,
                    estimatedCost = request.estimatedCost,
                    actualCost = request.actualCost,
                    servings = request.servings,
                    status = request.status,
                    notes = request.notes
                )
                mealRepository.updateMeal(updated)
                loadData()
                mealToEdit = null
            }
        )
    }
    
    mealToDelete?.let { meal ->
        AlertDialog(
            onDismissRequest = { mealToDelete = null },
            title = { Text("Supprimer le repas ?") },
            text = { Text("Voulez-vous vraiment supprimer \"${meal.name}\" ?") },
            confirmButton = {
                TextButton(
                    onClick = {
                        mealRepository.deleteMeal(meal.id)
                        loadData()
                        mealToDelete = null
                    },
                    colors = ButtonDefaults.textButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text("Supprimer")
                }
            },
            dismissButton = {
                TextButton(onClick = { mealToDelete = null }) {
                    Text("Annuler")
                }
            }
        )
    }
    
    if (showAutoGenerateDialog) {
        AutoGenerateMealsDialog(
            eventId = eventId,
            onDismiss = { showAutoGenerateDialog = false },
            onGenerate = { request ->
                val generatedMeals = MealPlanner.autoGenerateMeals(request)
                generatedMeals.forEach { meal ->
                    val mealRequest = MealRequest(
                        eventId = meal.eventId,
                        type = meal.type,
                        name = meal.name,
                        date = meal.date,
                        time = meal.time,
                        location = meal.location,
                        responsibleParticipantIds = meal.responsibleParticipantIds,
                        estimatedCost = meal.estimatedCost,
                        actualCost = meal.actualCost,
                        servings = meal.servings,
                        status = meal.status,
                        notes = meal.notes
                    )
                    mealRepository.createMeal(mealRequest)
                }
                loadData()
                showAutoGenerateDialog = false
            }
        )
    }
    
    if (showDietaryRestrictionsDialog) {
        DietaryRestrictionsDialog(
            eventId = eventId,
            restrictions = dietaryRestrictions,
            mealRepository = mealRepository,
            onDismiss = { 
                loadData()
                showDietaryRestrictionsDialog = false 
            }
        )
    }
}

/**
 * Summary card showing meal statistics
 */
@Composable
fun MealSummaryCard(
    meals: List<Meal>,
    dietaryRestrictions: List<ParticipantDietaryRestriction>
) {
    val summary = MealPlanner.generateMealSummary(meals)
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Text(
                "Résumé",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        "Total repas",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        summary.totalMeals.toString(),
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold
                    )
                }
                
                Column {
                    Text(
                        "Coût estimé",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        "${summary.totalEstimatedCost / 100.0}€",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
                
                Column {
                    Text(
                        "Terminés",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        "${summary.mealsCompleted}/${summary.totalMeals}",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.tertiary
                    )
                }
            }
            
            if (dietaryRestrictions.isNotEmpty()) {
                HorizontalDivider()
                Text(
                    "${dietaryRestrictions.size} contrainte(s) alimentaire(s)",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.error
                )
            }
        }
    }
}

/**
 * Filter chips row
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MealFiltersRow(
    selectedType: MealType?,
    selectedStatus: MealStatus?,
    onTypeSelected: (MealType) -> Unit,
    onStatusSelected: (MealStatus) -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Type filters
        Text(
            "Type",
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            MealType.entries.forEach { type ->
                FilterChip(
                    selected = selectedType == type,
                    onClick = { onTypeSelected(type) },
                    label = { Text(getMealTypeLabel(type)) }
                )
            }
        }
        
        // Status filters
        Text(
            "Statut",
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            MealStatus.entries.forEach { status ->
                FilterChip(
                    selected = selectedStatus == status,
                    onClick = { onStatusSelected(status) },
                    label = { Text(getMealStatusLabel(status)) }
                )
            }
        }
    }
    
    Spacer(Modifier.height(8.dp))
}

/**
 * Daily schedule section (meals grouped by date)
 */
@Composable
fun DailyScheduleSection(
    schedule: DailyMealSchedule,
    onMealClick: (Meal) -> Unit,
    onDeleteClick: (Meal) -> Unit
) {
    Column(
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Date header
        val dateFormatter = DateTimeFormatter.ofPattern("EEEE d MMMM yyyy")
        val formattedDate = try {
            LocalDate.parse(schedule.date).format(dateFormatter)
        } catch (e: Exception) {
            schedule.date
        }
        
        Text(
            formattedDate,
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.primary
        )
        
        // Meals for this date
        schedule.meals.sortedBy { it.time }.forEach { meal ->
            MealCard(
                meal = meal,
                onClick = { onMealClick(meal) },
                onDeleteClick = { onDeleteClick(meal) }
            )
        }
    }
}

/**
 * Individual meal card
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MealCard(
    meal: Meal,
    onClick: () -> Unit,
    onDeleteClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        colors = CardDefaults.cardColors(
            containerColor = when (meal.status) {
                MealStatus.COMPLETED -> MaterialTheme.colorScheme.tertiaryContainer
                MealStatus.IN_PROGRESS -> MaterialTheme.colorScheme.primaryContainer
                MealStatus.CANCELLED -> MaterialTheme.colorScheme.errorContainer
                else -> MaterialTheme.colorScheme.surfaceVariant
            }
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                // Time + Type badge
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        meal.time,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                    
                    AssistChip(
                        onClick = {},
                        label = { Text(getMealTypeLabel(meal.type)) },
                        leadingIcon = {
                            Icon(
                                getMealTypeIcon(meal.type),
                                contentDescription = null,
                                modifier = Modifier.size(16.dp)
                            )
                        }
                    )
                }
                
                // Meal name
                Text(
                    meal.name,
                    style = MaterialTheme.typography.bodyLarge
                )
                
                // Location
                meal.location?.let { location ->
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            Icons.Default.LocationOn,
                            contentDescription = null,
                            modifier = Modifier.size(16.dp),
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            location,
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
                
                // Responsible + Servings + Cost
                Row(
                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    if (meal.responsibleParticipantIds.isNotEmpty()) {
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(4.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                Icons.Default.Person,
                                contentDescription = null,
                                modifier = Modifier.size(14.dp),
                                tint = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Text(
                                "${meal.responsibleParticipantIds.size}",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                    
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            Icons.Default.Restaurant,
                            contentDescription = null,
                            modifier = Modifier.size(14.dp),
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            "${meal.servings}",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    
                    Text(
                        "${meal.estimatedCost / 100.0}€",
                        style = MaterialTheme.typography.bodySmall,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
                
                // Status badge
                AssistChip(
                    onClick = {},
                    label = { Text(getMealStatusLabel(meal.status)) },
                    colors = AssistChipDefaults.assistChipColors(
                        containerColor = when (meal.status) {
                            MealStatus.COMPLETED -> MaterialTheme.colorScheme.tertiary
                            MealStatus.IN_PROGRESS -> MaterialTheme.colorScheme.primary
                            MealStatus.CANCELLED -> MaterialTheme.colorScheme.error
                            else -> MaterialTheme.colorScheme.secondary
                        },
                        labelColor = when (meal.status) {
                            MealStatus.COMPLETED -> MaterialTheme.colorScheme.onTertiary
                            MealStatus.IN_PROGRESS -> MaterialTheme.colorScheme.onPrimary
                            MealStatus.CANCELLED -> MaterialTheme.colorScheme.onError
                            else -> MaterialTheme.colorScheme.onSecondary
                        }
                    )
                )
            }
            
            // Delete button
            IconButton(onClick = onDeleteClick) {
                Icon(
                    Icons.Default.Delete,
                    contentDescription = "Supprimer",
                    tint = MaterialTheme.colorScheme.error
                )
            }
        }
    }
}

// Helper functions

fun getMealTypeLabel(type: MealType): String = when (type) {
    MealType.BREAKFAST -> "Petit-déj"
    MealType.LUNCH -> "Déjeuner"
    MealType.DINNER -> "Dîner"
    MealType.SNACK -> "Goûter"
    MealType.APERITIF -> "Apéritif"
}

fun getMealTypeIcon(type: MealType) = when (type) {
    MealType.BREAKFAST -> Icons.Default.Egg
    MealType.LUNCH -> Icons.Default.LunchDining
    MealType.DINNER -> Icons.Default.DinnerDining
    MealType.SNACK -> Icons.Default.Cake
    MealType.APERITIF -> Icons.Default.LocalBar
}

fun getMealStatusLabel(status: MealStatus): String = when (status) {
    MealStatus.PLANNED -> "Planifié"
    MealStatus.ASSIGNED -> "Assigné"
    MealStatus.IN_PROGRESS -> "En cours"
    MealStatus.COMPLETED -> "Terminé"
    MealStatus.CANCELLED -> "Annulé"
}
