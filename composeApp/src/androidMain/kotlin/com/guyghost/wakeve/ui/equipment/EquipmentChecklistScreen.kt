package com.guyghost.wakeve.ui.equipment

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.outlined.Comment
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.guyghost.wakeve.equipment.EquipmentManager
import com.guyghost.wakeve.equipment.EquipmentRepository
import com.guyghost.wakeve.models.*
import com.guyghost.wakeve.ui.activity.ParticipantInfo
import com.guyghost.wakeve.comment.CommentRepository
import com.guyghost.wakeve.models.CommentSection

/**
 * Equipment Checklist Screen
 *
 * Features:
 * - List equipment items grouped by category
 * - Filter by status
 * - Assign items to participants
 * - Update item status (checkboxes)
 * - Auto-generate checklist from event type
 * - Display statistics and progress
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EquipmentChecklistScreen(
    eventId: String,
    participants: List<ParticipantInfo>,
    equipmentRepository: EquipmentRepository,
    commentRepository: CommentRepository,
    onNavigateBack: () -> Unit,
    onNavigateToComments: (eventId: String, section: CommentSection, sectionItemId: String?) -> Unit
) {
    var equipmentItems by remember { mutableStateOf<List<EquipmentItem>>(emptyList()) }
    var selectedStatus by remember { mutableStateOf<ItemStatus?>(null) }
    var showAddItemDialog by remember { mutableStateOf(false) }
    var showAutoGenerateDialog by remember { mutableStateOf(false) }
    var itemToEdit by remember { mutableStateOf<EquipmentItem?>(null) }
    var itemToDelete by remember { mutableStateOf<EquipmentItem?>(null) }
    var showAssignDialog by remember { mutableStateOf<EquipmentItem?>(null) }
    var stats by remember { mutableStateOf<EquipmentChecklist?>(null) }
    var commentCount by remember { mutableIntStateOf(0) }

    // Load data
    fun loadData() {
        equipmentItems = equipmentRepository.getEquipmentItemsByEventId(eventId)
        stats = equipmentRepository.getEquipmentChecklist(eventId)
        commentCount = commentRepository.countCommentsBySection(eventId, CommentSection.EQUIPMENT).toInt()
    }

    LaunchedEffect(eventId) {
        loadData()
    }

    // Filter items
    val filteredItems = equipmentItems.filter { item ->
        selectedStatus == null || item.status == selectedStatus
    }

    // Group by category
    val itemsByCategory = filteredItems.groupBy { it.category }
        .toList()
        .sortedBy { it.first.ordinal }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Liste d'équipement") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.Default.ArrowBack, "Retour")
                    }
                },
                actions = {
                    // Auto-generate button
                    IconButton(onClick = { showAutoGenerateDialog = true }) {
                        Icon(Icons.Default.AutoAwesome, "Générer automatiquement")
                    }

                    // Comments icon with badge
                    IconButton(onClick = {
                        onNavigateToComments(eventId, CommentSection.EQUIPMENT, null)
                    }) {
                        Box {
                            Icon(
                                Icons.Outlined.Comment,
                                contentDescription = if (commentCount == 0) "Aucun commentaire" else "$commentCount commentaires"
                            )
                            if (commentCount > 0) {
                                Box(
                                    modifier = Modifier
                                        .size(16.dp)
                                        .background(
                                            color = MaterialTheme.colorScheme.error,
                                            shape = CircleShape
                                        )
                                        .align(Alignment.TopEnd),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Text(
                                        text = commentCount.toString(),
                                        style = MaterialTheme.typography.labelSmall,
                                        color = MaterialTheme.colorScheme.onError,
                                        fontWeight = FontWeight.Bold
                                    )
                                }
                            }
                        }
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = { showAddItemDialog = true }
            ) {
                Icon(Icons.Default.Add, "Ajouter un équipement")
            }
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        ) {
            // Statistics Card
            stats?.let { checklistStats ->
                EquipmentStatsCard(
                    stats = checklistStats,
                    participantCount = participants.size,
                    modifier = Modifier.padding(16.dp)
                )
            }

            // Filter Chips
            LazyRow(
                modifier = Modifier.padding(horizontal = 16.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                item {
                    FilterChip(
                        selected = selectedStatus == null,
                        onClick = { selectedStatus = null },
                        label = { Text("Tous") }
                    )
                }

                ItemStatus.entries.forEach { status ->
                    item {
                        FilterChip(
                            selected = selectedStatus == status,
                            onClick = {
                                selectedStatus = if (selectedStatus == status) null else status
                            },
                            label = { Text(getStatusLabel(status)) },
                            leadingIcon = {
                                Icon(
                                    imageVector = when (status) {
                                        ItemStatus.NEEDED -> Icons.Default.Circle
                                        ItemStatus.ASSIGNED -> Icons.Default.Person
                                        ItemStatus.CONFIRMED -> Icons.Default.CheckCircle
                                        ItemStatus.PACKED -> Icons.Default.CheckCircleOutline
                                        ItemStatus.CANCELLED -> Icons.Default.Cancel
                                    },
                                    contentDescription = null,
                                    modifier = Modifier.size(16.dp)
                                )
                            }
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Equipment List by Category
            if (filteredItems.isEmpty()) {
                EmptyStateCard(
                    message = if (equipmentItems.isEmpty())
                        "Aucun équipement ajouté"
                    else
                        "Aucun équipement avec ce statut",
                    actionLabel = if (equipmentItems.isEmpty()) "Générer une liste" else null,
                    onActionClick = if (equipmentItems.isEmpty()) {
                        { showAutoGenerateDialog = true }
                    } else {
                        null
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                )
            } else {
                LazyColumn(
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    itemsByCategory.forEach { (category, items) ->
                        item {
                            CategorySection(
                                category = category,
                                items = items,
                                participants = participants,
                                onItemClick = { item -> itemToEdit = item },
                                onAssignClick = { item -> showAssignDialog = item },
                                onStatusChange = { item, newStatus ->
                                    val updated = item.copy(status = newStatus)
                                    equipmentRepository.updateEquipmentItem(updated)
                                    loadData()
                                },
                                onDeleteClick = { item -> itemToDelete = item }
                            )
                        }
                    }
                }
            }
        }
    }

    // Dialogs
    if (showAddItemDialog) {
        AddEditItemDialog(
            item = null,
            participants = participants,
            onDismiss = { showAddItemDialog = false },
            onConfirm = { item ->
                equipmentRepository.createEquipmentItem(item.copy(eventId = eventId))
                showAddItemDialog = false
                loadData()
            }
        )
    }

    itemToEdit?.let { item ->
        AddEditItemDialog(
            item = item,
            participants = participants,
            onDismiss = { itemToEdit = null },
            onConfirm = { updated ->
                equipmentRepository.updateEquipmentItem(updated)
                itemToEdit = null
                loadData()
            }
        )
    }

    showAssignDialog?.let { item ->
        AssignItemDialog(
            item = item,
            participants = participants,
            onDismiss = { showAssignDialog = null },
            onConfirm = { participantId ->
                val updated = item.copy(
                    assignedTo = participantId,
                    status = if (participantId != null) ItemStatus.ASSIGNED else ItemStatus.NEEDED
                )
                equipmentRepository.updateEquipmentItem(updated)
                showAssignDialog = null
                loadData()
            }
        )
    }

    if (showAutoGenerateDialog) {
        AutoGenerateDialog(
            onDismiss = { showAutoGenerateDialog = false },
            onConfirm = { eventType ->
                val generated = EquipmentManager.createChecklist(
                    eventId = eventId,
                    eventType = eventType
                )
                generated.forEach { item: EquipmentItem ->
                    equipmentRepository.createEquipmentItem(item)
                }
                showAutoGenerateDialog = false
                loadData()
            }
        )
    }

    itemToDelete?.let { item ->
        AlertDialog(
            onDismissRequest = { itemToDelete = null },
            title = { Text("Supprimer l'équipement ?") },
            text = { Text("Voulez-vous vraiment supprimer « ${item.name} » ?") },
            confirmButton = {
                TextButton(onClick = {
                    equipmentRepository.deleteEquipmentItem(item.id)
                    itemToDelete = null
                    loadData()
                }) {
                    Text("Supprimer", color = MaterialTheme.colorScheme.error)
                }
            },
            dismissButton = {
                TextButton(onClick = { itemToDelete = null }) {
                    Text("Annuler")
                }
            }
        )
    }
}

@Composable
private fun EquipmentStatsCard(
    stats: EquipmentChecklist,
    participantCount: Int,
    modifier: Modifier = Modifier
) {
    val sharedCostPerPerson = if (participantCount > 0) stats.totalCost / participantCount else 0L

    Card(
        modifier = modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Text(
                text = "Progression",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )

            // Progress Bar
            val progress = if (stats.totalItems > 0)
                stats.packedItems.toFloat() / stats.totalItems
            else
                0f

            Column(verticalArrangement = Arrangement.spacedBy(4.dp)) {
                LinearProgressIndicator(
                    progress = { progress },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(8.dp),
                )

                Text(
                    text = "${stats.packedItems} / ${stats.totalItems} équipements emballés (${(progress * 100).toInt()}%)",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            // Status Summary
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        text = (stats.totalItems - stats.assignedItems - stats.confirmedItems - stats.packedItems).toString(),
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = "Requis",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }

                Column {
                    Text(
                        text = stats.assignedItems.toString(),
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.primary
                    )
                    Text(
                        text = "Assignés",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }

                Column {
                    Text(
                        text = stats.confirmedItems.toString(),
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.tertiary
                    )
                    Text(
                        text = "Confirmés",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            HorizontalDivider()

            // Cost Summary
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        text = "Coût total",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = "${stats.totalCost / 100}€",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                }

                Column(horizontalAlignment = Alignment.End) {
                    Text(
                        text = "Par personne",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = "${sharedCostPerPerson / 100}€",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
            }
        }
    }
}

@Composable
private fun CategorySection(
    category: EquipmentCategory,
    items: List<EquipmentItem>,
    participants: List<ParticipantInfo>,
    onItemClick: (EquipmentItem) -> Unit,
    onAssignClick: (EquipmentItem) -> Unit,
    onStatusChange: (EquipmentItem, ItemStatus) -> Unit,
    onDeleteClick: (EquipmentItem) -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = getCategoryLabel(category),
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )

                Badge {
                    Text(items.size.toString())
                }
            }

            Spacer(modifier = Modifier.height(12.dp))

            items.forEach { item ->
                EquipmentItemRow(
                    item = item,
                    participants = participants,
                    onClick = { onItemClick(item) },
                    onAssignClick = { onAssignClick(item) },
                    onStatusChange = { newStatus -> onStatusChange(item, newStatus) },
                    onDeleteClick = { onDeleteClick(item) }
                )

                if (item != items.last()) {
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
                }
            }
        }
    }
}

@Composable
private fun EquipmentItemRow(
    item: EquipmentItem,
    participants: List<ParticipantInfo>,
    onClick: () -> Unit,
    onAssignClick: () -> Unit,
    onStatusChange: (ItemStatus) -> Unit,
    onDeleteClick: () -> Unit
) {
    var expanded by remember { mutableStateOf(false) }

    Column {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { expanded = !expanded },
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(
                        text = item.name,
                        style = MaterialTheme.typography.bodyLarge,
                        fontWeight = FontWeight.Medium
                    )

                    if (item.quantity > 1) {
                        Text(
                            text = " × ${item.quantity}",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }

                item.notes?.let { notes ->
                    if (notes.isNotBlank()) {
                        Text(
                            text = notes,
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }

                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Status Badge
                    StatusBadge(status = item.status)

                    // Assigned Person
                    item.assignedTo?.let { participantId ->
                        val participant = participants.find { it.id == participantId }
                        participant?.let {
                            AssistChip(
                                onClick = onAssignClick,
                                label = { Text(it.name, style = MaterialTheme.typography.labelSmall) },
                                leadingIcon = {
                                    Icon(
                                        Icons.Default.Person,
                                        contentDescription = null,
                                        modifier = Modifier.size(16.dp)
                                    )
                                }
                            )
                        }
                    } ?: run {
                        AssistChip(
                            onClick = onAssignClick,
                            label = { Text("Assigner", style = MaterialTheme.typography.labelSmall) },
                            leadingIcon = {
                                Icon(
                                    Icons.Default.PersonAdd,
                                    contentDescription = null,
                                    modifier = Modifier.size(16.dp)
                                )
                            }
                        )
                    }

                    // Cost
                    item.sharedCost?.let { cost ->
                        if (cost > 0) {
                            Text(
                                text = "${cost / 100}€",
                                style = MaterialTheme.typography.labelMedium,
                                color = MaterialTheme.colorScheme.primary
                            )
                        }
                    }
                }
            }

            // Status Checkbox
            Checkbox(
                checked = item.status == ItemStatus.PACKED,
                onCheckedChange = { checked ->
                    val newStatus = if (checked) ItemStatus.PACKED else {
                        if (item.assignedTo != null) ItemStatus.CONFIRMED else ItemStatus.NEEDED
                    }
                    onStatusChange(newStatus)
                }
            )
        }

        // Expanded Actions
        if (expanded) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 8.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                AssistChip(
                    onClick = onClick,
                    label = { Text("Modifier") },
                    leadingIcon = {
                        Icon(Icons.Default.Edit, null, modifier = Modifier.size(16.dp))
                    }
                )

                AssistChip(
                    onClick = onDeleteClick,
                    label = { Text("Supprimer") },
                    leadingIcon = {
                        Icon(Icons.Default.Delete, null, modifier = Modifier.size(16.dp))
                    },
                    colors = AssistChipDefaults.assistChipColors(
                        labelColor = MaterialTheme.colorScheme.error
                    )
                )
            }
        }
    }
}

@Composable
private fun StatusBadge(status: ItemStatus) {
    val (color, label) = when (status) {
        ItemStatus.NEEDED -> MaterialTheme.colorScheme.outline to "Requis"
        ItemStatus.ASSIGNED -> MaterialTheme.colorScheme.primary to "Assigné"
        ItemStatus.CONFIRMED -> MaterialTheme.colorScheme.tertiary to "Confirmé"
        ItemStatus.PACKED -> MaterialTheme.colorScheme.secondary to "Emballé"
        ItemStatus.CANCELLED -> MaterialTheme.colorScheme.error to "Annulé"
    }

    SuggestionChip(
        onClick = {},
        label = { Text(label, style = MaterialTheme.typography.labelSmall) },
        colors = SuggestionChipDefaults.suggestionChipColors(
            containerColor = color.copy(alpha = 0.1f),
            labelColor = color
        )
    )
}

@Composable
private fun EmptyStateCard(
    message: String,
    actionLabel: String? = null,
    onActionClick: (() -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(32.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Icon(
                imageVector = Icons.Default.Inventory,
                contentDescription = null,
                modifier = Modifier.size(64.dp),
                tint = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Text(
                text = message,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            if (actionLabel != null && onActionClick != null) {
                Button(onClick = onActionClick) {
                    Text(actionLabel)
                }
            }
        }
    }
}

private fun getCategoryLabel(category: EquipmentCategory): String {
    return when (category) {
        EquipmentCategory.CAMPING -> "Camping"
        EquipmentCategory.SPORTS -> "Sport"
        EquipmentCategory.COOKING -> "Cuisine"
        EquipmentCategory.ELECTRONICS -> "Électronique"
        EquipmentCategory.SAFETY -> "Sécurité"
        EquipmentCategory.OTHER -> "Autre"
    }
}

private fun getStatusLabel(status: ItemStatus): String {
    return when (status) {
        ItemStatus.NEEDED -> "Requis"
        ItemStatus.ASSIGNED -> "Assigné"
        ItemStatus.CONFIRMED -> "Confirmé"
        ItemStatus.PACKED -> "Emballé"
        ItemStatus.CANCELLED -> "Annulé"
    }
}
