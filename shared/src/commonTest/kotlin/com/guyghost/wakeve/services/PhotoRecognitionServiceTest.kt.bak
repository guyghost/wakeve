package com.guyghost.wakeve.services

import com.guyghost.wakeve.models.Album
import com.guyghost.wakeve.models.BoundingBox
import com.guyghost.wakeve.models.FaceDetection
import com.guyghost.wakeve.models.Photo
import com.guyghost.wakeve.models.PhotoCategory
import com.guyghost.wakeve.models.PhotoTag
import com.guyghost.wakeve.models.TagSource
import kotlinx.coroutines.test.runTest
import kotlinx.datetime.Clock
import kotlin.random.Random
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

/**
 * Unit tests for PhotoRecognitionService.
 * Tests cover photo processing, album creation, search, and similarity detection.
 */
class PhotoRecognitionServiceTest {
    
    private lateinit var mockAndroidRecognition: FakePlatformPhotoRecognition
    private lateinit var mockIosRecognition: FakePlatformPhotoRecognition
    private lateinit var mockPhotoRepository: FakePhotoRepository
    private lateinit var mockAlbumRepository: FakeAlbumRepository
    
    private fun createService(): PhotoRecognitionService {
        mockAndroidRecognition = FakePlatformPhotoRecognition()
        mockIosRecognition = FakePlatformPhotoRecognition()
        mockPhotoRepository = FakePhotoRepository()
        mockAlbumRepository = FakeAlbumRepository()
        
        return PhotoRecognitionService(
            androidPhotoRecognition = mockAndroidRecognition,
            iosPhotoRecognition = null, // Use Android service for testing
            photoRepository = mockPhotoRepository,
            albumRepository = mockAlbumRepository
        )
    }
    
    // ================ Photo Processing Tests ================
    
    @Test
    fun `processPhoto detects faces and tags photo`() = runTest {
        val service = createService()
        val photoId = "photo-123"
        val imageBytes = byteArrayOf(1, 2, 3)
        
        // Configure mock to return face and tag data
        mockAndroidRecognition.facesToReturn = listOf(
            FaceDetection(BoundingBox(0, 0, 100, 100), 0.95)
        )
        mockAndroidRecognition.tagsToReturn = listOf(
            PhotoTag(
                tagId = "tag-1",
                label = "Beach Party",
                confidence = 0.92,
                category = PhotoCategory.LOCATION,
                source = TagSource.AUTO,
                suggestedAt = "2025-06-15T10:00:00Z"
            )
        )
        
        val result = service.processPhoto(photoId, imageBytes)
        
        assertEquals(photoId, result.photoId)
        assertEquals(1, result.facesDetected)
        assertEquals(1, result.tagsSuggested)
        assertTrue(result.suggestedAlbums.isNotEmpty())
    }
    
    @Test
    fun `processPhoto handles empty results gracefully`() = runTest {
        val service = createService()
        val photoId = "photo-empty"
        val imageBytes = byteArrayOf(1, 2, 3)
        
        // Configure mock to return empty results
        mockAndroidRecognition.facesToReturn = emptyList()
        mockAndroidRecognition.tagsToReturn = emptyList()
        
        val result = service.processPhoto(photoId, imageBytes)
        
        assertEquals(photoId, result.photoId)
        assertEquals(0, result.facesDetected)
        assertEquals(0, result.tagsSuggested)
    }
    
    // ================ Album Creation Tests ================
    
    @Test
    fun `createAutoAlbum creates album with correct name`() = runTest {
        val service = createService()
        val eventId = "event-123"
        
        // Add photos to repository
        mockPhotoRepository.photos["photo-1"] = createTestPhoto("photo-1", eventId)
        mockPhotoRepository.photos["photo-2"] = createTestPhoto("photo-2", eventId)
        
        val album = service.createAutoAlbum(eventId)
        
        assertNotNull(album)
        assertEquals(eventId, album.eventId)
        assertTrue(album.isAutoGenerated)
        assertEquals(2, album.photoIds.size)
        assertNotNull(album.coverPhotoId)
    }
    
    @Test
    fun `createAutoAlbum throws exception when no photos`() = runTest {
        val service = createService()
        val eventId = "event-empty"
        
        val exception = kotlin.runCatching {
            service.createAutoAlbum(eventId)
        }.exceptionOrNull()
        
        assertNotNull(exception)
        assertTrue(exception is IllegalStateException)
        assertTrue(exception.message?.contains("No photos") == true)
    }
    
    @Test
    fun `createAutoAlbum uses favorite as cover photo`() = runTest {
        val service = createService()
        val eventId = "event-favorites"
        
        val normalPhoto = createTestPhoto("photo-normal", eventId, isFavorite = false)
        val favoritePhoto = createTestPhoto("photo-favorite", eventId, isFavorite = true)
        
        mockPhotoRepository.photos["photo-normal"] = normalPhoto
        mockPhotoRepository.photos["photo-favorite"] = favoritePhoto
        
        val album = service.createAutoAlbum(eventId)
        
        assertEquals("photo-favorite", album.coverPhotoId)
    }
    
    @Test
    fun `createCustomAlbum creates album with specified name`() = runTest {
        val service = createService()
        val albumName = "Week-end Ski Trip"
        val photoIds = listOf("photo-1", "photo-2", "photo-3")
        val eventId = "event-123"
        
        photoIds.forEach { photoId ->
            mockPhotoRepository.photos[photoId] = createTestPhoto(photoId, eventId)
        }
        
        val album = service.createCustomAlbum(albumName, photoIds, eventId)
        
        assertEquals(albumName, album.name)
        assertFalse(album.isAutoGenerated)
        assertEquals(photoIds.size, album.photoIds.size)
        assertEquals(photoIds.first(), album.coverPhotoId)
    }
    
    // ================ Search Tests ================
    
    @Test
    fun `searchPhotos finds matching tags`() = runTest {
        val service = createService()
        val eventId = "event-search"
        
        // Add photos with different tags
        val beachPhoto = createTestPhoto(
            id = "photo-beach",
            eventId = eventId,
            tags = listOf(
                createTag("Beach Party", PhotoCategory.LOCATION, 0.92)
            )
        )
        val foodPhoto = createTestPhoto(
            id = "photo-food",
            eventId = eventId,
            tags = listOf(
                createTag("Pizza", PhotoCategory.FOOD, 0.88)
            )
        )
        
        mockPhotoRepository.photos["photo-beach"] = beachPhoto
        mockPhotoRepository.photos["photo-food"] = foodPhoto
        mockPhotoRepository.searchResults = listOf(beachPhoto, foodPhoto)
        
        val results = service.searchPhotos("Beach", PhotoSearchFilters(eventId = eventId))
        
        assertEquals(1, results.size)
        assertEquals("photo-beach", results.first().photo.id)
        assertTrue(results.first().relevanceScore > 0)
    }
    
    @Test
    fun `searchPhotos filters by event`() = runTest {
        val service = createService()
        
        val event1Photo = createTestPhoto("photo-e1", "event-1")
        val event2Photo = createTestPhoto("photo-e2", "event-2")
        
        mockPhotoRepository.photos["photo-e1"] = event1Photo
        mockPhotoRepository.photos["photo-e2"] = event2Photo
        mockPhotoRepository.searchResults = listOf(event1Photo, event2Photo)
        
        val results = service.searchPhotos("", PhotoSearchFilters(eventId = "event-1"))
        
        assertEquals(1, results.size)
        assertEquals("event-1", results.first().photo.eventId)
    }
    
    @Test
    fun `searchPhotos returns empty for blank query`() = runTest {
        val service = createService()
        
        val results = service.searchPhotos("   ")
        
        assertTrue(results.isEmpty())
    }
    
    @Test
    fun `searchPhotos sorts by relevance score`() = runTest {
        val service = createService()
        
        // Add photos with matching and non-matching tags
        val exactMatch = createTestPhoto(
            id = "photo-exact",
            eventId = "event-1",
            tags = listOf(createTag("Beach Party", PhotoCategory.LOCATION, 0.95))
        )
        val partialMatch = createTestPhoto(
            id = "photo-partial",
            eventId = "event-1",
            tags = listOf(createTag("Beach", PhotoCategory.LOCATION, 0.80))
        )
        
        mockPhotoRepository.photos["photo-exact"] = exactMatch
        mockPhotoRepository.photos["photo-partial"] = partialMatch
        mockPhotoRepository.searchResults = listOf(exactMatch, partialMatch)
        
        val results = service.searchPhotos("Beach Party")
        
        assertEquals(2, results.size)
        assertTrue(results.first().relevanceScore >= results.last().relevanceScore)
    }
    
    // ================ Similar Photos Tests ================
    
    @Test
    fun `findSimilarPhotos returns photos with overlapping tags`() = runTest {
        val service = createService()
        
        val sourcePhoto = createTestPhoto(
            id = "photo-source",
            eventId = "event-1",
            tags = listOf(
                createTag("Beach", PhotoCategory.LOCATION),
                createTag("Party", PhotoCategory.DECORATION)
            )
        )
        val similarPhoto = createTestPhoto(
            id = "photo-similar",
            eventId = "event-1",
            tags = listOf(
                createTag("Beach", PhotoCategory.LOCATION),
                createTag("Friends", PhotoCategory.PEOPLE)
            )
        )
        val differentPhoto = createTestPhoto(
            id = "photo-diff",
            eventId = "event-1",
            tags = listOf(
                createTag("Food", PhotoCategory.FOOD),
                createTag("Dinner", PhotoCategory.FOOD)
            )
        )
        
        mockPhotoRepository.photos["photo-source"] = sourcePhoto
        mockPhotoRepository.photos["photo-similar"] = similarPhoto
        mockPhotoRepository.photos["photo-diff"] = differentPhoto
        
        val similarPhotos = service.findSimilarPhotos("photo-source")
        
        assertEquals(1, similarPhotos.size)
        assertEquals("photo-similar", similarPhotos.first().id)
    }
    
    @Test
    fun `findSimilarPhotos returns empty for unknown photo`() = runTest {
        val service = createService()
        
        val similarPhotos = service.findSimilarPhotos("unknown-photo")
        
        assertTrue(similarPhotos.isEmpty())
    }
    
    @Test
    fun `findSimilarPhotos excludes reference photo`() = runTest {
        val service = createService()
        
        val photo = createTestPhoto(
            id = "photo-source",
            eventId = "event-1",
            tags = listOf(createTag("Beach", PhotoCategory.LOCATION))
        )
        
        mockPhotoRepository.photos["photo-source"] = photo
        
        val similarPhotos = service.findSimilarPhotos("photo-source")
        
        assertTrue(similarPhotos.none { it.id == "photo-source" })
    }
    
    // ================ Helper Methods ================
    
    private fun createTestPhoto(
        id: String,
        eventId: String,
        isFavorite: Boolean = false,
        tags: List<PhotoTag> = emptyList()
    ): Photo {
        return Photo(
            id = id,
            eventId = eventId,
            url = "https://photos.app/$id",
            localPath = null,
            thumbnailUrl = "https://photos.app/thumb/$id",
            caption = null,
            uploadedAt = "2025-06-15T10:00:00Z",
            tags = tags,
            faceDetections = emptyList(),
            albums = emptyList(),
            isFavorite = isFavorite
        )
    }
    
    private fun createTag(
        label: String,
        category: PhotoCategory,
        confidence: Double = 0.85
    ): PhotoTag {
        val timestamp = Clock.System.now().toEpochMilliseconds()
        val random = Random.nextInt(1000000)
        return PhotoTag(
            tagId = "tag-$timestamp-$random",
            label = label,
            confidence = confidence,
            category = category,
            source = TagSource.AUTO,
            suggestedAt = "2025-06-15T10:00:00Z"
        )
    }
    
    // ================ Mock Classes ================
    
    private class FakePlatformPhotoRecognition : PlatformPhotoRecognitionService {
        var facesToReturn: List<FaceDetection> = emptyList()
        var tagsToReturn: List<PhotoTag> = emptyList()
        
        override suspend fun detectFaces(image: Any?): List<FaceDetection> = facesToReturn
        override suspend fun tagPhoto(image: Any?): List<PhotoTag> = tagsToReturn
    }
    
    private class FakePhotoRepository : PhotoRepository {
        val photos = mutableMapOf<String, Photo>()
        var searchResults: List<Photo> = emptyList()
        
        override suspend fun getPhoto(photoId: String): Photo? = photos[photoId]
        override suspend fun getPhotosByEvent(eventId: String): List<Photo> =
            photos.values.filter { it.eventId == eventId }
        override suspend fun getAllPhotos(): List<Photo> = photos.values.toList()
        override suspend fun savePhoto(photo: Photo) { photos[photo.id] = photo }
        override suspend fun updatePhotoCaption(photoId: String, caption: String?) {}
        override suspend fun updatePhotoWithTags(
            photoId: String,
            faces: List<FaceDetection>,
            tags: List<PhotoTag>
        ) {
            photos[photoId]?.let { photo ->
                photos[photoId] = photo.copy(
                    faceDetections = faces,
                    tags = tags
                )
            }
        }
        override suspend fun addTagsToPhoto(photoId: String, tags: List<PhotoTag>) {}
        override suspend fun removeTagFromPhoto(photoId: String, tagId: String) {}
        override suspend fun addPhotoToAlbum(photoId: String, albumId: String) {}
        override suspend fun removePhotoFromAlbum(photoId: String, albumId: String) {}
        override suspend fun searchByQuery(query: String): List<Photo> = searchResults
        override suspend fun getPhotosByMinConfidence(minConfidence: Double): List<Photo> =
            photos.values.filter { photo ->
                photo.tags.any { it.confidence >= minConfidence }
            }
        override suspend fun getPhotosWithFaces(): List<Photo> =
            photos.values.filter { it.faceDetections.isNotEmpty() }
        override suspend fun deletePhoto(photoId: String) { photos.remove(photoId) }
        override suspend fun setFavorite(photoId: String, isFavorite: Boolean) {
            photos[photoId]?.let { photo ->
                photos[photoId] = photo.copy(isFavorite = isFavorite)
            }
        }
    }
    
    private class FakeAlbumRepository : AlbumRepository {
        private val albums = mutableMapOf<String, Album>()
        
        override suspend fun createAlbum(album: Album) { albums[album.id] = album }
        override suspend fun getAlbums(eventId: String?): List<Album> =
            if (eventId != null) albums.values.filter { it.eventId == eventId }
            else albums.values.toList()
        override suspend fun getAlbum(albumId: String): Album? = albums[albumId]
        override suspend fun updateAlbum(album: Album) { albums[album.id] = album }
        override suspend fun updateAlbumName(albumId: String, name: String) {
            albums[albumId]?.let { album ->
                albums[albumId] = album.copy(name = name)
            }
        }
        override suspend fun updateAlbumCover(albumId: String, coverPhotoId: String) {
            albums[albumId]?.let { album ->
                albums[albumId] = album.copy(coverPhotoId = coverPhotoId)
            }
        }
        override suspend fun deleteAlbum(albumId: String) { albums.remove(albumId) }
        override suspend fun addPhotoToAlbum(albumId: String, photoId: String) {
            albums[albumId]?.let { album ->
                if (!album.photoIds.contains(photoId)) {
                    albums[albumId] = album.copy(
                        photoIds = album.photoIds + photoId
                    )
                }
            }
        }
        override suspend fun removePhotoFromAlbum(albumId: String, photoId: String) {
            albums[albumId]?.let { album ->
                albums[albumId] = album.copy(
                    photoIds = album.photoIds - photoId
                )
            }
        }
        override suspend fun getAutoGeneratedAlbums(): List<Album> =
            albums.values.filter { it.isAutoGenerated }
        override suspend fun getCustomAlbums(): List<Album> =
            albums.values.filter { !it.isAutoGenerated }
        override suspend fun searchAlbumsByName(query: String): List<Album> =
            albums.values.filter { it.name.contains(query, ignoreCase = true) }
    }
}
