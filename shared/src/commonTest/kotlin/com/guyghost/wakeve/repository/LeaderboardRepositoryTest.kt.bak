package com.guyghost.wakeve.repository

import com.guyghost.wakeve.gamification.Badge
import com.guyghost.wakeve.gamification.BadgeCategory
import com.guyghost.wakeve.gamification.BadgeRarity
import com.guyghost.wakeve.gamification.LeaderboardEntry
import com.guyghost.wakeve.gamification.LeaderboardType
import com.guyghost.wakeve.gamification.UserBadges
import com.guyghost.wakeve.gamification.UserPoints
import com.guyghost.wakeve.gamification.repository.UserBadgesRepository
import com.guyghost.wakeve.gamification.repository.UserPointsRepository
import kotlinx.coroutines.test.runTest
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertNull
import kotlin.test.assertTrue

/**
 * Unit tests for LeaderboardRepository.
 * Tests leaderboard retrieval, caching, filtering, and ranking logic.
 */
class LeaderboardRepositoryTest {

    private lateinit var userPointsRepository: FakeUserPointsRepository
    private lateinit var userBadgesRepository: FakeUserBadgesRepository
    private lateinit var getUsername: (String) -> String
    private lateinit var repository: InMemoryLeaderboardRepository

    // Test data
    private val testUsers = listOf(
        UserPoints("user-1", 1000, 500, 200, 100, 200, 0, "2025-01-01T10:00:00Z"),
        UserPoints("user-2", 800, 300, 300, 100, 100, 0, "2025-01-02T10:00:00Z"),
        UserPoints("user-3", 1200, 600, 200, 200, 200, 0, "2025-01-03T10:00:00Z"),
        UserPoints("user-4", 500, 100, 100, 100, 200, 0, "2025-01-04T10:00:00Z"),
        UserPoints("user-5", 1500, 800, 300, 200, 200, 0, "2025-01-05T10:00:00Z"),
        UserPoints("user-6", 300, 50, 50, 100, 100, 0, "2025-01-06T10:00:00Z"),
        UserPoints("user-7", 2000, 1000, 400, 300, 300, 0, "2025-01-07T10:00:00Z"),
        UserPoints("user-8", 600, 200, 150, 100, 150, 0, "2025-01-08T10:00:00Z")
    )

    private val testBadges = mapOf(
        "user-1" to listOf(
            Badge("badge-1", "Badge 1", "Desc", "üèÜ", 1, 50, BadgeCategory.CREATION, BadgeRarity.COMMON)
        ),
        "user-3" to listOf(
            Badge("badge-2", "Badge 2", "Desc", "‚≠ê", 10, 100, BadgeCategory.VOTING, BadgeRarity.EPIC),
            Badge("badge-3", "Badge 3", "Desc", "üëë", 1, 200, BadgeCategory.CREATION, BadgeRarity.LEGENDARY)
        ),
        "user-5" to listOf(
            Badge("badge-4", "Badge 4", "Desc", "üíé", 5, 75, BadgeCategory.PARTICIPATION, BadgeRarity.RARE)
        )
    )

    @Test
    fun `getLeaderboard returns all-time ranking sorted by points`() = runTest {
        setupRepository()

        val leaderboard = repository.getLeaderboard(LeaderboardType.ALL_TIME, limit = 20)

        assertEquals(8, leaderboard.size)
        // Verify sorted by points descending
        assertEquals("user-7", leaderboard[0].userId)  // 2000 points
        assertEquals("user-5", leaderboard[1].userId)  // 1500 points
        assertEquals("user-3", leaderboard[2].userId)  // 1200 points
        assertEquals("user-1", leaderboard[3].userId)  // 1000 points
        assertEquals("user-2", leaderboard[4].userId)  // 800 points
        assertEquals("user-8", leaderboard[5].userId)  // 600 points
        assertEquals("user-4", leaderboard[6].userId)  // 500 points
        assertEquals("user-6", leaderboard[7].userId)  // 300 points
    }

    @Test
    fun `getLeaderboard respects limit parameter`() = runTest {
        setupRepository()

        val leaderboard = repository.getLeaderboard(LeaderboardType.ALL_TIME, limit = 3)

        assertEquals(3, leaderboard.size)
        assertEquals("user-7", leaderboard[0].userId)
        assertEquals("user-5", leaderboard[1].userId)
        assertEquals("user-3", leaderboard[2].userId)
    }

    @Test
    fun `getLeaderboard assigns correct ranks`() = runTest {
        setupRepository()

        val leaderboard = repository.getLeaderboard(LeaderboardType.ALL_TIME, limit = 5)

        assertEquals(1, leaderboard[0].rank)
        assertEquals(2, leaderboard[1].rank)
        assertEquals(3, leaderboard[2].rank)
        assertEquals(4, leaderboard[3].rank)
        assertEquals(5, leaderboard[4].rank)
    }

    @Test
    fun `getLeaderboard marks current user correctly`() = runTest {
        setupRepository()

        val leaderboard = repository.getLeaderboard(
            type = LeaderboardType.ALL_TIME,
            currentUserId = "user-3"
        )

        val currentUserEntry = leaderboard.find { it.userId == "user-3" }
        assertNotNull(currentUserEntry)
        assertTrue(currentUserEntry.isCurrentUser)

        // Other users should not be marked as current user
        val otherUserEntry = leaderboard.find { it.userId == "user-1" }
        assertNotNull(otherUserEntry)
        assertEquals(false, otherUserEntry.isCurrentUser)
    }

    @Test
    fun `getLeaderboard marks friends correctly`() = runTest {
        setupRepository()

        val friendIds = listOf("user-2", "user-5")
        val leaderboard = repository.getLeaderboard(
            type = LeaderboardType.ALL_TIME,
            friendIds = friendIds
        )

        val friendEntry = leaderboard.find { it.userId == "user-2" }
        assertNotNull(friendEntry)
        assertTrue(friendEntry.isFriend)

        val nonFriendEntry = leaderboard.find { it.userId == "user-1" }
        assertNotNull(nonFriendEntry)
        assertEquals(false, nonFriendEntry.isFriend)
    }

    @Test
    fun `getUserRank returns correct rank`() = runTest {
        setupRepository()

        val rank = repository.getUserRank("user-5", LeaderboardType.ALL_TIME)

        assertEquals(2, rank)  // user-5 has 1500 points, 2nd place
    }

    @Test
    fun `getUserRank returns null for non-ranked user`() = runTest {
        setupRepository()

        val rank = repository.getUserRank("non-existent-user", LeaderboardType.ALL_TIME)

        assertNull(rank)
    }

    @Test
    fun `getUserRankWithEntry returns correct pair`() = runTest {
        setupRepository()

        val result = repository.getUserRankWithEntry("user-3", LeaderboardType.ALL_TIME)

        assertNotNull(result)
        val (rank, entry) = result
        assertEquals(3, rank)
        assertEquals("user-3", entry.userId)
        assertEquals(1200, entry.totalPoints)
    }

    @Test
    fun `leaderboard cache expires after 5 minutes`() = runTest {
        setupRepository()

        // First call - populates cache
        val firstCall = repository.getLeaderboard(LeaderboardType.ALL_TIME)
        assertEquals(8, firstCall.size)

        // Simulate cache expiration (for testing, we'd need to manipulate time)
        // In a real test, we would use a clock abstraction
        repository.refreshLeaderboardCache()

        // Cache should be cleared
        val secondCall = repository.getLeaderboard(LeaderboardType.ALL_TIME)
        assertEquals(8, secondCall.size)
    }

    @Test
    fun `refreshLeaderboardCache clears all caches`() = runTest {
        setupRepository()

        // Populate cache
        repository.getLeaderboard(LeaderboardType.ALL_TIME)

        // Refresh
        repository.refreshLeaderboardCache()

        // Cache should be empty
        val leaderboard = repository.getLeaderboard(LeaderboardType.ALL_TIME)
        assertEquals(8, leaderboard.size)
    }

    @Test
    fun `friends filter returns only friends`() = runTest {
        setupRepository()

        val friendIds = listOf("user-1", "user-3", "user-5")
        val leaderboard = repository.getLeaderboard(
            type = LeaderboardType.FRIENDS,
            friendIds = friendIds
        )

        assertEquals(3, leaderboard.size)
        assertTrue(leaderboard.all { it.userId in friendIds })
    }

    @Test
    fun `friends filter returns empty list when no friends`() = runTest {
        setupRepository()

        val leaderboard = repository.getLeaderboard(
            type = LeaderboardType.FRIENDS,
            friendIds = emptyList()
        )

        assertTrue(leaderboard.isEmpty())
    }

    @Test
    fun `this month and this week filters work`() = runTest {
        setupRepository()

        // These currently use the same implementation as ALL_TIME
        // but filter by timestamp in a full implementation
        val monthLeaderboard = repository.getLeaderboard(LeaderboardType.THIS_MONTH)
        val weekLeaderboard = repository.getLeaderboard(LeaderboardType.THIS_WEEK)

        assertEquals(8, monthLeaderboard.size)
        assertEquals(8, weekLeaderboard.size)
    }

    @Test
    fun `getLeaderboard includes badges count`() = runTest {
        setupRepository()

        val leaderboard = repository.getLeaderboard(LeaderboardType.ALL_TIME)

        val user3Entry = leaderboard.find { it.userId == "user-3" }
        assertNotNull(user3Entry)
        assertEquals(2, user3Entry.badgesCount)  // user-3 has 2 badges

        val user1Entry = leaderboard.find { it.userId == "user-1" }
        assertNotNull(user1Entry)
        assertEquals(1, user1Entry.badgesCount)  // user-1 has 1 badge

        val user2Entry = leaderboard.find { it.userId == "user-2" }
        assertNotNull(user2Entry)
        assertEquals(0, user2Entry.badgesCount)  // user-2 has no badges
    }

    @Test
    fun `entries are sorted by points with ties resolved by badge rarity`() = runTest {
        // Create users with same points but different badges
        userPointsRepository = FakeUserPointsRepository(
            listOf(
                UserPoints("user-a", 1000, 500, 200, 100, 200, 0, ""),
                UserPoints("user-b", 1000, 500, 200, 100, 200, 0, ""),
                UserPoints("user-c", 1000, 500, 200, 100, 200, 0, "")
            )
        )
        userBadgesRepository = FakeUserBadgesRepository(
            mapOf(
                "user-a" to listOf(
                    Badge("b1", "B1", "D", "‚≠ê", 1, 50, BadgeCategory.CREATION, BadgeRarity.COMMON)
                ),
                "user-b" to listOf(
                    Badge("b2", "B2", "D", "‚≠ê", 1, 50, BadgeCategory.CREATION, BadgeRarity.EPIC)
                ),
                "user-c" to emptyList()
            )
        )
        getUsername = { "User" }
        repository = InMemoryLeaderboardRepository(
            userPointsRepository,
            userBadgesRepository,
            getUsername
        )

        val leaderboard = repository.getLeaderboard(LeaderboardType.ALL_TIME)

        // user-b with EPIC badge should come first
        assertEquals("user-b", leaderboard[0].userId)
        assertEquals("user-a", leaderboard[1].userId)
        assertEquals("user-c", leaderboard[2].userId)
    }

    // ================ Helper Classes ================

    private fun setupRepository() {
        userPointsRepository = FakeUserPointsRepository(testUsers)
        userBadgesRepository = FakeUserBadgesRepository(testBadges)
        getUsername = { "User-${it.substringAfter("user-")}" }
        repository = InMemoryLeaderboardRepository(
            userPointsRepository,
            userBadgesRepository,
            getUsername
        )
    }
}

/**
 * Fake implementation of UserPointsRepository for testing.
 */
class FakeUserPointsRepository(
    private val points: List<UserPoints>
) : UserPointsRepository {

    private val pointsMap = points.associateBy { it.userId }.toMutableMap()

    override suspend fun getUserPoints(userId: String): UserPoints? {
        return pointsMap[userId]
    }

    override suspend fun getUserPointsOrDefault(userId: String): UserPoints {
        return pointsMap[userId] ?: UserPoints(userId, 0, 0, 0, 0, 0, 0, "")
    }

    override suspend fun createUserPoints(userId: String): UserPoints {
        val newPoints = UserPoints(userId, 0, 0, 0, 0, 0, 0, "")
        pointsMap[userId] = newPoints
        return newPoints
    }

    override suspend fun incrementEventCreationPoints(userId: String, points: Int): UserPoints {
        val current = getUserPointsOrDefault(userId)
        val updated = current.copy(
            eventCreationPoints = current.eventCreationPoints + points,
            totalPoints = current.totalPoints + points
        )
        pointsMap[userId] = updated
        return updated
    }

    override suspend fun incrementVotingPoints(userId: String, points: Int): UserPoints {
        val current = getUserPointsOrDefault(userId)
        val updated = current.copy(
            votingPoints = current.votingPoints + points,
            totalPoints = current.totalPoints + points
        )
        pointsMap[userId] = updated
        return updated
    }

    override suspend fun incrementCommentPoints(userId: String, points: Int): UserPoints {
        val current = getUserPointsOrDefault(userId)
        val updated = current.copy(
            commentPoints = current.commentPoints + points,
            totalPoints = current.totalPoints + points
        )
        pointsMap[userId] = updated
        return updated
    }

    override suspend fun incrementParticipationPoints(userId: String, points: Int): UserPoints {
        val current = getUserPointsOrDefault(userId)
        val updated = current.copy(
            participationPoints = current.participationPoints + points,
            totalPoints = current.totalPoints + points
        )
        pointsMap[userId] = updated
        return updated
    }

    override suspend fun applyPointsDecay(userId: String): UserPoints? {
        return getUserPoints(userId)
    }

    override suspend fun getTopPointEarners(limit: Int): List<UserPoints> {
        return pointsMap.values
            .sortedByDescending { it.totalPoints }
            .take(limit)
    }

    override suspend fun getPointsStatistics(): Map<String, Long> {
        val values = pointsMap.values
        return mapOf(
            "userCount" to values.size.toLong(),
            "totalPoints" to values.sumOf { it.totalPoints.toLong() },
            "averagePoints" to if (values.isNotEmpty()) values.sumOf { it.totalPoints }.toLong() / values.size.toLong() else 0L,
            "maxPoints" to (values.maxOfOrNull { it.totalPoints } ?: 0).toLong(),
            "minPoints" to (values.minOfOrNull { it.totalPoints } ?: 0).toLong()
        )
    }

    override suspend fun userHasMinimumPoints(userId: String, minimumPoints: Int): Boolean {
        return (getUserPoints(userId)?.totalPoints ?: 0) >= minimumPoints
    }

    override suspend fun getTotalPoints(userId: String): Int {
        return getUserPoints(userId)?.totalPoints ?: 0
    }

    override suspend fun deleteUserPoints(userId: String) {
        pointsMap.remove(userId)
    }
}

/**
 * Fake implementation of UserBadgesRepository for testing.
 */
class FakeUserBadgesRepository(
    private val badges: Map<String, List<Badge>>
) : UserBadgesRepository {

    private val unlockedBadges = mutableMapOf<String, MutableList<Badge>>()

    init {
        unlockedBadges.putAll(badges.mapValues { it.value.toMutableList() })
    }

    override suspend fun getUserBadges(userId: String): UserBadges {
        val userBadges = unlockedBadges[userId] ?: emptyList()
        return UserBadges(userId, userBadges)
    }

    override suspend fun getAllBadgeDefinitions(): List<Badge> {
        return badges.values.flatten().distinctBy { it.id }
    }

    override suspend fun unlockBadge(userId: String, badgeId: String): Boolean {
        val badge = getAllBadgeDefinitions().find { it.id == badgeId } ?: return false
        if (userHasBadge(userId, badgeId)) return false

        unlockedBadges.getOrPut(userId) { mutableListOf() }.add(badge)
        return true
    }

    override suspend fun userHasBadge(userId: String, badgeId: String): Boolean {
        return unlockedBadges[userId]?.any { it.id == badgeId } == true
    }

    override suspend fun getNearCompletionBadges(userId: String): List<Badge> {
        return emptyList()
    }

    override suspend fun getBadgeCountByRarity(userId: String): Map<BadgeRarity, Int> {
        val userBadges = unlockedBadges[userId] ?: return emptyMap()
        return userBadges.groupBy { it.rarity }.mapValues { it.value.size }
    }

    override suspend fun getNextBadge(userId: String): Badge? {
        return null
    }

    override suspend fun getUserBadgePoints(userId: String): Int {
        return unlockedBadges[userId]?.sumOf { it.pointsReward } ?: 0
    }

    override suspend fun acknowledgeBadge(userId: String, badgeId: String) {
        // No-op for testing
    }

    override suspend fun getUnacknowledgedBadges(userId: String): List<Badge> {
        return unlockedBadges[userId]?.toList() ?: emptyList()
    }

    override suspend fun deleteAllUserBadges(userId: String) {
        unlockedBadges.remove(userId)
    }
}
